## Calculate UNDO_RETENTION  for given UNDO Tabespace

`SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       ROUND((d.undo_size / (to_number(f.value) *
       g.undo_block_per_sec))) "OPTIMAL UNDO RETENTION [Sec]"
  FROM (
       SELECT SUM(a.bytes) undo_size
          FROM v$datafile a,
               v$tablespace b,
               dba_tablespaces c
         WHERE c.contents = 'UNDO'
           AND c.status = 'ONLINE'
           AND b.name = c.tablespace_name
           AND a.ts# = b.ts#
       ) d,
       v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
              undo_block_per_sec
         FROM v$undostat
       ) g
WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size'
/ 
'

ACTUAL UNDO SIZE [MByte] UNDO RETENTION [Sec]      OPTIMAL UNDO RETENTION [Sec]
------------------------ ------------------------- ----------------------------
                   19640 900                                              27342


## Calculate Needed UNDO Size for given Database Activity 

SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       (TO_NUMBER(e.value) * TO_NUMBER(f.value) *
       g.undo_block_per_sec) / (1024*1024) 
      "NEEDED UNDO SIZE [MByte]"
  FROM (
       SELECT SUM(a.bytes) undo_size
         FROM v$datafile a,
              v$tablespace b,
              dba_tablespaces c
        WHERE c.contents = 'UNDO'
          AND c.status = 'ONLINE'
          AND b.name = c.tablespace_name
          AND a.ts# = b.ts#
       ) d,
      v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
         undo_block_per_sec
         FROM v$undostat
       ) g
 WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size'
/

ACTUAL UNDO SIZE [MByte] UNDO RETENTION [Sec]      NEEDED UNDO SIZE [MByte]
------------------------ ------------------------- ------------------------
                   19640 900                                     646.488281

## Identify active transactions in undo and rollback segments
#####################################################
col o format a10
col u format a10
select osuser o, username u, sid,
segment_name s, substr(sa.sql_text,1,200) txt
from v$session s,
v$transaction t,
dba_rollback_segs r,
v$sqlarea sa
where s.taddr=t.addr
and t.xidusn=r.segment_id(+)
and s.sql_address=sa.address(+)
And substr(sa.sql_text,1,200) is not null
order by 3;

col name format a8
col username format a8
col osuser format a8
col start_time format a17
col status format a12
tti 'Active transactions'
select username, osuser,
t.start_time, r.name, t.used_ublk "ROLLB BLKS",
decode(t.space, 'YES', 'SPACE TX',
decode(t.recursive, 'YES', 'RECURSIVE TX',
decode(t.noundo, 'YES', 'NO UNDO TX', t.status)
)) status
from sys.v_$transaction t, sys.v_$rollname r, sys.v_$session s
where t.xidusn = r.usn
and t.ses_addr = s.saddr
/

It is sometimes useful to know which users are accessing the rollback segments. This is important information when a user is continually filling the rollbacks and causing extents to be thrown.

Statistics of the rollback segments currently used by instance 
========================================================
SELECT T1.NAME, T2.EXTENTS, T2.RSSIZE, T2.OPTSIZE, T2.HWMSIZE,
T2.XACTS, T2.STATUS
FROM V$ROLLNAME T1, V$ROLLSTAT T2
WHERE T1.USN = T2.USN AND
T1.NAME LIKE '%RBS%';
 

# rolbusrs.sql

SELECT r.name "Rollback Segment Name ",
               p.spid "System Process Id ",
               s.username||'(`||l.sid||')' "Oracle User Pid"
FROM v$lock l, v$process p, v$rollname r, v$session s
WHERE  l.sid = p.pid(+)
AND s.sid=l.sid
AND TRUNC (l.id1(+)/65536) = r.usn
AND l.type(+) = 'TX'
AND l.lmode(+) = 6
ORDER BY r.name

Segment online/offline and tablespace name
++++++++++++++++++++++++++++++++++

select 	SEGMENT_NAME,
	OWNER,
	TABLESPACE_NAME,
	SEGMENT_ID,
	FILE_ID,
	BLOCK_ID,
	INITIAL_EXTENT,
	NEXT_EXTENT,
	MIN_EXTENTS,
	MAX_EXTENTS,
	PCT_INCREASE,
	STATUS,
	INSTANCE_NUM
from 	dba_rollback_segs
order	by SEGMENT_NAME


Bringing a Rollback Segment Online: Example 
This statements brings the rollback segment rbs_one online:

ALTER ROLLBACK SEGMENT rbs_one ONLINE; 
Resizing a Rollback Segment: Example 
This statements shrinks the rollback segment rbs_one:

ALTER ROLLBACK SEGMENT rbs_one SHRINK TO 100M;

There are several v$ views that are helpful in viewing rollback segment activity.  While the contents of these views are very straightforward, most Remote DBA run pre-written scripts to see the performance of their rollback segments.

set pause off;
set linesize 80;
set pagesize 60;
set newpage 0; 

column c0 heading "Name"    format 99 
column c1 heading "sz now"   format 9,999 
column c2 heading "extends" format 9,999
column c3 heading "# trans." format 9,999
column c4 heading "wraps" format 9,999
column c5 heading "High WM" format 999;
column c7 heading "Shrinks" format 999;
column c6 heading "status" 

ttitle "dbname Database|Rollback Segment Access"; 

select usn      c0,
       rssize/1048576   c1,
       hwmsize/1048576  c5,
       extends  c2,
       xacts    c3,
       wraps    c4,
       shrinks  c7,
       substr(status,1,7) c6
from v$rollstat; 

spool off; 

SQL> @rbs 

Mon Jul 26                                                             page    1
                                dbname Database
                            Rollback Segment Access 

Name sz now High WM extends # trans.  wraps Shrinks status
---- ------ ------- ------- -------- ------ ------- -------
   0      0       0       0        0      0       0 ONLINE
   1     60      60       0        0      4       0 ONLINE
   2    100     100       0        0      4       0 ONLINE

This first script displays all of the important columns in v$rollstat.  The most important columns here are the high water mark, the number of time the rollback segment extended, and the number of transactions currently within the rollback segment.  

If we are experiencing rollback segment contention we might see a non-zero value for the “extends” column, and a non-zero value for the number of transactions currently using the rollback segment.  If either of these conditions exists, we would add additional rollback segments. 

[NOTE:

CREATE ROLLBACK SEGMENT "R09" 
    TABLESPACE "RBS" 
    STORAGE ( INITIAL 256K NEXT 128K OPTIMAL NULL MINEXTENTS 1 
    MAXEXTENTS 32765)
ALTER ROLLBACK SEGMENT "R09" ONLINE
]

Now let’s look at a script to display rollback segment contention.

prompt
prompt
prompt **********************************************************
prompt  Rollback Segment Section
prompt **********************************************************
prompt if any count below is > 1% of the total number of requests for data
prompt then more rollback segments are needed 

select class, count
  from v$waitstat
where class in ('system undo header','system undo block',
                'undo header','undo block')
group by class,count; 

column "Tot # of Requests for Data" format 999,999,999,999,999
select sum(value) "Tot # of Requests for Data" from v$sysstat where
name in ('db block gets', 'consistent gets');

prompt

prompt         =========================
prompt          ROLLBACK SEGMENT CONTENTION
prompt         =========================
prompt
prompt          If any ratio is > .01 then more rollback segments are needed 

column "Ratio" format 99.99999
select name, waits, gets, waits/gets "Ratio"
  from v$rollstat a, v$rollname b
where a.usn = b.usn;

**********************************************************
Rollback Segment Section
**********************************************************
if any count below is > 1% of the total number of requests for data
then more rollback segments are needed
 
CLASS                   COUNT
------------------ ----------
system undo block           0
system undo header          0
undo block                 12
undo header               654
 

Tot # of Requests for Data
--------------------------
             3,181,939,107

=========================
ROLLBACK SEGMENT CONTENTION
========================= 

If any ratio is > .01 then more rollback segments are needed 

                            Rollback Segment Access 

NAME                                WAITS       GETS     Ratio
------------------------------ ---------- ---------- ---------
SYSTEM                                  0       2814    .00000
R02                                     5     866311    .00001
R10                                     2     888075    .00000
R09                                     2     862449    .00000
R08                                     5     885778    .00001
R07                                    11     349035    .00003
R06                                     2     861073    .00000
R05                                     2     357749    .00001
R04                                     3     147468    .00002
R03                                     6     877603    .00001

10 rows selected.

There are two sections for this report.  

The first section checks v$waitstat for any waits relating to Oracle rollback segment activity.  If any of these wait counts are greater than 1% of the total requests for data, then more rollback segments are needed.

The second section checks v$rollstat and shows all rollback segments waits as a function of rollback segment gets.  If the ratio of waits to gets exceeds 1%, then there are not enough rollback segments.

=============================================================================

ARTBUX01:ARTPRD (SYSTEM)> select max (MAXQUERYLEN)
  2   from v$undostat;

MAX(MAXQUERYLEN)
----------------
            1511

Rollback segment management

1) take offline the current online rollback segments. 
select 'alter rollback segment '||segment_name||' offline;'
from dba_rollback_segs
where status ='ONLINE'
and segment_name <> 'SYSTEM';

2) drop the offline rollback segments
select 'drop rollback segment '||segment_name||';'
from dba_rollback_segs
where status ='OFFLINE'
and segment_name <> 'SYSTEM';


3) Create rollback segments with small - 20M initial select 'create rollback segment '||segment_name||' storage ( initial 20M next 10M  maxextents 32765);'
from rollback_segment_bkp
where segment_name like 'SMALL%';

4) create rollback segment with big - 200M initial select 'create rollback segment '||segment_name||' storage ( initial 200M next 10M  maxextents 32765);'
from rollback_segment_bkp
where segment_name like 'BIG%';

5) take all new rollback segments online. 
select 'alter rollback segment '||segment_name||' online;'
from dba_rollback_segs
where status ='OFFLINE'
and segment_name <> 'SYSTEM';


RECREATE TEMP Tablespace
COLUMN property_name FORMAT A30
COLUMN property_value FORMAT A30
COLUMN description FORMAT A50
SET LINESIZE 200

SELECT *
FROM database_properties
WHERE property_name like '%TABLESPACE';

PROPERTY_NAME                  PROPERTY_VALUE                 DESCRIPTION
------------------------------ ------------------------------ --------------------------------------------------
DEFAULT_TEMP_TABLESPACE        TEMP                           Name of default temporary tablespace
DEFAULT_PERMANENT_TABLESPACE   USERS                          Name of default permanent tablespace

SQL> 

CREATE TEMPORARY TABLESPACE temp2
TEMPFILE '/u03/ORADBS/IJISPROD/TEMP03.dbf' SIZE 2824M REUSE
AUTOEXTEND ON NEXT 1M MAXSIZE 4000M
EXTENT MANAGEMENT LOCAL UNIFORM SIZE 1M; 

Tablespace created.

SQL> ALTER DATABASE DEFAULT TEMPORARY TABLESPACE temp2;

Database altered.

SQL> SELECT *
FROM database_properties
WHERE property_name like '%TABLESPACE';  

PROPERTY_NAME                  PROPERTY_VALUE                 DESCRIPTION
------------------------------ ------------------------------ --------------------------------------------------
DEFAULT_TEMP_TABLESPACE        TEMP2                          Name of default temporary tablespace
DEFAULT_PERMANENT_TABLESPACE   USERS                          Name of default permanent tablespace


SELECT username ,session_num ,session_addr ,tablespace
FROM v$sort_usage
WHERE tablespace='TEMP';


SELECT s.username ,s.session_num ,s.session_addr ,b.module
FROM v$sort_usage s,v$session b
WHERE tablespace='TEMP'
and s.session_addr=b.saddr;

SELECT 'ALTER SYSTEM KILL SESSION ''' || sid ||','|| serial# || ''';'
FROM v$session
WHERE saddr='C00000009E6F6118'; 


SQL> DROP TABLESPACE temp INCLUDING CONTENTS AND DATAFILES;

Tablespace dropped.
drop tablespace temp including contents and datafiles;

SQL> CREATE TEMPORARY TABLESPACE temp
TEMPFILE '/u03/ORADBS/IJISPROD/TEMP01.dbf' SIZE 6000M REUSE
AUTOEXTEND ON NEXT 1M MAXSIZE 8000M
EXTENT MANAGEMENT LOCAL UNIFORM SIZE 1M;   

Tablespace created.

SQL> ALTER DATABASE DEFAULT TEMPORARY TABLESPACE temp;

Database altered.

SQL> DROP TABLESPACE temp2 INCLUDING CONTENTS AND DATAFILES;

Tablespace dropped.


====================

Alter database tempfile '' drop;

================
Recreate Undo
================
SELECT DISTINCT tablespace_name,STATUS, SUM(BYTES), COUNT(*)

            FROM DBA_UNDO_EXTENTS GROUP BY tablespace_name,STATUS;

SQL> alter system set undo_retention=0 scope=memory;
SQL> show parameter undo

SQL> shutdown immediate;
SQL> startup
SQL> drop tablespace undoqwic including contents and datafiles;
drop tablespace undoqwic including contents and datafiles
*
ERROR at line 1:
ORA-30013: undo tablespace 'UNDOQWIC' is currently in use

SQL> create undo tablespace undoqwic01 datafile '/QWIC1/oradata/PRRO/UNDOQWIC02.DBF' size 1500M;

Tablespace created.

SQL> alter system set undo_tablespace = undoqwic01;

System altered.

SQL> drop tablespace undoqwic including contents and datafiles;

Tablespace dropped.

SQL> create undo tablespace undoqwic datafile '/QWIC1/oradata/PRRO/UNDOQWIC01.dbf' size 1500M;

Tablespace created.

SQL> alter system set undo_tablespace = undoqwic;

System altered.

SQL> drop tablespace undoqwic01 including contents and datafiles;

Tablespace dropped.

SQL> alter system set undo_retention=900 scope=memory;

System altered.

SQL>
=========================

SQL> create undo tablespace undoqwic00 datafile '/BASEQWIC/oradata/STATS/UNDOQWIC00.DBF' size 1500M;

Tablespace created.

SQL> alter system set undo_tablespace = undoqwic00;

System altered.

SQL> drop tablespace undoqwic including contents and datafiles;

Tablespace dropped.

SQL> create undo tablespace undoqwic datafile '/BASEQWIC/oradata/STATS/UNDOQWIC01.dbf' size 5500M;

Tablespace created.

SQL> alter system set undo_tablespace = undoqwic;

System altered.

SQL> drop tablespace undoqwic00 including contents and datafiles;

Tablespace dropped.

SQL> alter system set undo_retention=900 scope=memory;

System altered.

SQL> drop tablespace undoqwic including contents and datafiles;
drop tablespace undoqwic including contents and datafiles
*
ERROR at line 1:
ORA-01548: active rollback segment '_SYSSMU62$' found, terminate dropping tablespace

SQL> drop tablespace undoqwic including contents and datafiles;
drop tablespace undoqwic including contents and datafiles
*
ERROR at line 1:
ORA-30013: undo tablespace 'UNDOQWIC' is currently in use

============
TEMP USAGE
=========
To check instance-wise total allocated, total used TEMP for both rac and non-rac
set lines 152
col FreeSpaceGB format 999.999
col UsedSpaceGB format 999.999
col TotalSpaceGB format 999.999
col instance_name format a10
col host_name format a30
col tablespace_name format a30
select tablespace_name,
(free_blocks*8)/1024/1024 FreeSpaceGB,
(used_blocks*8)/1024/1024 UsedSpaceGB,
(total_blocks*8)/1024/1024 TotalSpaceGB,
i.instance_name,i.host_name
from gv$sort_segment ss,gv$instance i where ss.tablespace_name in (select tablespace_name from dba_tablespaces where contents='TEMPORARY') and
 i.inst_id=ss.inst_id;

TABLESPACE_NAME                FREESPACEGB USEDSPACEGB TOTALSPACEGB INSTANCE_N HOST_NAME
------------------------------ ----------- ----------- ------------ ---------- ------------------------------
TEMP                                19.987        .011       19.998 TMTR1_1    iorsdb02-adm.apac.ent.bhpbilli
                                                                               ton.net


RAC : Monitor the temp space allocation to make sure each instance has enough temp space available and that the temp space is allocated evenly among the instances. The following SQL is used:

select inst_id, tablespace_name, segment_file, total_blocks, 
used_blocks, free_blocks, max_used_blocks, max_sort_blocks 
from gv$sort_segment;

select inst_id, tablespace_name, blocks_cached, blocks_used 
from gv$temp_extent_pool;

select inst_id,tablespace_name, blocks_used, blocks_free 
from gv$temp_space_header;

select inst_id,free_requests,freed_extents 
from gv$sort_segment;

--
-- determine temporary tablespace activity
--
--

col tablespace_name format a15 trunc heading "Tablespace" just center
col total_space format 9,999,999,999 heading "Total|Space" just center
col used_space format 9,999,999,999 heading "Used|Space" just center
col current_users format 999 heading "Active|Users" just center
col extent_size format 99,999,999 heading "Extent|Size" just center
col total_extents format 9,999 heading "Allocated|Extents" just center
col used_extents format 9,999 heading "Used|Extents" just center
col free_extents format 9,999 heading "Free|Extents" just center
col available_extents format 9,999 heading "Available|Extents" just center

set lines 120

select
  a.tablespace_name,
  sum(a.bytes) total_space,
  b.used_extents * 8192.5 * b.extent_size used_space,
  b.current_users,
  b.extent_size * 8192.5 extent_size,
  b.total_extents,
  b.used_extents,
  b.free_extents,
  (sum(a.bytes) - (b.used_extents * 8192.5 * b.extent_size))/(b.extent_size * 8192.5) available_extents
from
  dba_temp_files a,
  v$sort_segment b
where
  a.tablespace_name = b.tablespace_name
group by
  a.tablespace_name,
  b.used_extents * 8192.5 * b.extent_size,
  b.current_users,
  b.extent_size,
  b.total_extents,
  b.used_extents,
  b.free_extents
/

                    Total           Used      Active   Extent    Allocated  Used    Free   Available
  Tablespace        Space          Space      Users     Size      Extents  Extents Extents  Extents
--------------- -------------- -------------- ------ ----------- --------- ------- ------- ---------
TEMP            ##############     23,070,080     22   1,048,640    ######      22  ######    ######


SELECT s.sid, s.serial#, s.username
,p.spid, s.module, p.program
,SUM(su.blocks) * tbsp.block_size/1024/1024 mb_used
,su.tablespace
FROM v$sort_usage su
,v$session s
,dba_tablespaces tbsp
,v$process p
WHERE su.session_addr = s.saddr
AND su.tablespace = tbsp.tablespace_name
AND s.paddr = p.addr
GROUP BY
s.sid, s.serial#, s.username, s.osuser, p.spid, s.module,
p.program, tbsp.block_size, su.tablespace
ORDER BY s.sid;

If don't defined a default temporary tablespace for a user, the SYSTEM tablespace is used to store SORT SEGMENTS.
==================================================================================
select current_users, extent_size, freed_extents, max_size, max_used_size
from v$SORT_SEGMENT
where tablespace_name='TEMP';

CURRENT_USERS EXTENT_SIZE FREED_EXTENTS   MAX_SIZE MAX_USED_SIZE
------------- ----------- ------------- ---------- -------------
            0         128             0       4999          4999

1 row selected.
Monitoring Temporary Tablespaces and Sorting:
Unlike datafiles, tempfiles are not listed in V$DATAFILE and DBA_DATA_FILES. Use V$TEMPFILE and DBA_TEMP_FILES instead.
One can monitor temporary segments from V$SORT_SEGMENT and V$SORT_USAGE
SQL> 

Examine statistics about temporary tablespace blocks:
============================================
COL TABLESPACE_NAME FOR A16
SELECT
TABLESPACE_NAME, CURRENT_USERS,
TOTAL_BLOCKS, USED_BLOCKS, FREE_BLOCKS,
MAX_BLOCKS, MAX_USED_BLOCKS, MAX_SORT_BLOCKS
FROM V$SORT_SEGMENT
ORDER BY TABLESPACE_NAME;

statistics about temporary tablespace extents:
======================================
SELECT
TABLESPACE_NAME, CURRENT_USERS, EXTENT_SIZE,
TOTAL_EXTENTS, USED_EXTENTS, FREE_EXTENTS,
EXTENT_HITS
FROM V$SORT_SEGMENT
ORDER BY TABLESPACE_NAME;

TEMP_USAGE:
--------------------------------------------------------------------------
rem
rem SQL*Plus script to display sort usage by user with join to v$session
rem to get session information (and correct user in some ver due to bug)
rem
column tablespace format a12
column username   format a12

break on username nodup skip 1

select   se.username
        ,se.sid
        ,su.extents
        ,su.blocks * to_number(rtrim(p.value)) as Space
        ,tablespace
        ,segtype
from     v$sort_usage su
        ,v$parameter  p
        ,v$session    se
where    p.name          = 'db_block_size'
and      su.session_addr = se.saddr
order by se.username, se.sid
/

Tempfile_usage.sql
column tablespace_name heading 'Tablespace' format a20
column tablespace heading 'Tablespace' format a20
column contents heading 'Contents' 
column spid heading 'System|Pid' 
column name heading 'File name' format a50
column username heading 'User' format a15
column total_blocks heading 'Total|blocks'
column used_blocks heading 'Used|blocks'
column blocks heading 'Used|blocks'
column free_blocks heading 'Free|blocks'
column max_used_blocks heading 'Max|blocks'

prompt
prompt Tempfile status -:
prompt

select STATUS, ENABLED, NAME from v$tempfile;

prompt
prompt Tempfile space -:
prompt

-- max_blocks is most blocks ever used by 1 transaction

select tablespace_name, total_blocks, used_blocks, 
free_blocks, max_used_blocks            
from v$sort_segment;

prompt
prompt Tempfile usage -:
prompt

SELECT s.username, u.tablespace, u.contents, u.blocks, p.spid
FROM v$session s, v$sort_usage u, v$process p
WHERE s.saddr=u.session_addr
AND s.paddr=p.addr;
===========================
TEMP USAGE: 

SELECT sysdate "TIME_STAMP", vsu.username, vs.sid, vp.spid, vs.sql_id, vst.sql_text, vsu.tablespace,
         sum_blocks*dt.block_size/1024/1024 usage_mb
     FROM
      (
              SELECT username, sqladdr, sqlhash, sql_id, tablespace, session_addr,
    -- sum(blocks)*8192/1024/1024 "USAGE_MB",
                 sum(blocks) sum_blocks
               FROM v$sort_usage
              HAVING SUM(blocks)> 1000
             GROUP BY username, sqladdr, sqlhash, sql_id, tablespace, session_addr
     ) "VSU",
     v$sqltext vst,
      v$session vs,
     v$process vp,
      dba_tablespaces dt
   WHERE vs.sql_id = vst.sql_id
   -- AND vsu.sqladdr = vst.address
  -- AND vsu.sqlhash = vst.hash_value
     AND vsu.session_addr = vs.saddr
      AND vs.paddr = vp.addr
     AND vst.piece = 0
     AND dt.tablespace_name = vsu.tablespace
 order by usage_mb;

TIME_STAM USERNAME         SID SPID         SQL_ID        SQL_TEXT                                           TABLESPACE        USAGE_MB
--------- --------------- ---- ------------ ------------- -------------------------------------------------- --------------- ----------
19-JAN-10 SYS              410 31514        1mkjj1tfvh41q SELECT COL1,COL2 FROM KSO.SKEW ORDER BY COL3, COL2 TEMP      191  

=================================
Free space:

free space for temporary tablespaces

select TABLESPACE_NAME, BYTES_USED, BYTES_FREE from V$TEMP_SPACE_HEADER;


DBSPI-0004.1: 1.00 users have default/temp tablespace of 'SYSTEM' in nmlprd.

select username,temporary_tablespace,default_tablespace
from dba_users where default_tablespace='SYSTEM';

or,

select username,temporary_tablespace,default_tablespace 
from dba_users where username = '&A';

alter user "userid" default tablespace user temporary tablespace temp;

========
 SQL : temp tablespace usage


/*
The query below will display which sessions are using TEMP tablespace and how much space is
being used by each session:
*/

SELECT   b.TABLESPACE
       , b.segfile#
       , b.segblk#
       , ROUND (  (  ( b.blocks * p.VALUE ) / 1024 / 1024 ), 2 ) size_mb
       , a.SID
       , a.serial#
       , a.username
       , a.osuser
       , a.program
       , a.status
    FROM v$session a
       , v$sort_usage b
       , v$process c
       , v$parameter p
   WHERE p.NAME = 'db_block_size'
     AND a.saddr = b.session_addr
     AND a.paddr = c.addr
ORDER BY b.TABLESPACE, b.segfile#, b.segblk#, b.blocks;


/*
To see how much space is being used and free in TEMP tablespace run the following sql:
*/

SELECT tablespace_name, SUM(bytes_used), SUM(bytes_free)
FROM   v$temp_space_header
GROUP  BY tablespace_name;


/*
Run the following statement to check the free space within the used portion of TEMPFILE (if
you are running older version of Oracle and don't have tempfile you can replace v$tempfile
with v$datafile):
*/

SELECT   A.tablespace_name tablespace, D.mb_total,
         SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_used,
         D.mb_total - SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_free
FROM     v$sort_segment A,
         (
         SELECT   B.name, C.block_size, SUM (C.bytes) / 1024 / 1024 mb_total
         FROM     v$tablespace B, v$tempfile C
         WHERE    B.ts#= C.ts#
         GROUP BY B.name, C.block_size
         ) D
WHERE    A.tablespace_name = D.name
GROUP by A.tablespace_name, D.mb_total;

;

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Who use/used my Temp tablespace? Temp tablespace usage history
If I wanted to see the session ids of the current users of temp space on a RAC system I would just join gv$tempseg_usage to gv$session for database with 8k block size :

select se.inst_id,se.sid,sum(tu.blocks)*8192
from
gv$tempseg_usage tu,
gv$session se
where
tu.inst_id=se.inst_id and
tu.session_addr=se.saddr and
tu.session_num=se.serial#
group by se.inst_id,se.sid
order by se.inst_id,se.sid;

But to go back in time you can use the TEMP_SPACE_ALLOCATED column of V$ACTIVE_SESSION_HISTORY or DBA_HIST_ACTIVE_SESS_HISTORY to identify a query that consumed a lot of temp space.

select sql_id,max(TEMP_SPACE_ALLOCATED)/(1024*1024*1024) gig
from DBA_HIST_ACTIVE_SESS_HISTORY
where
sample_time > sysdate-2 and
TEMP_SPACE_ALLOCATED > (5*1024*1024*1024)
group by sql_id order by sql_id;

This gives the sql_id and maximum allocated temp space of any queries that ran in the past two days and exceeded 5 gigabytes of temp space. This is a great feature of these ASH views. Now we can go back in time and find the queries that were using all the temp space and tune them.

-
-- Temporary Tablespace Usage.
--
COL TABLESPACE_SIZE FOR 999,999,999,999
COL ALLOCATED_SPACE FOR 999,999,999,999
COL FREE_SPACE FOR 999,999,999,999

SELECT *
FROM dba_temp_free_space
/

set pagesize 60 linesize 132 verify off
break on file_id skip 1
column file_id heading "File|Id"
column tablespace_name for a15
column object for a15
column owner for a15
column MBytes for 999,999
select tablespace_name,
'free space' owner, /*"owner" of free space */
' ' object, /*blank object name */
file_id, /*file id for the extent header*/
block_id, /*block id for the extent header*/
CEIL(blocks*4/1024) MBytes /*length of the extent, in Mega Bytes*/
from dba_free_space
where tablespace_name like '%TEMP%'
union
select tablespace_name,
substr(owner, 1, 20), /*owner name (first 20 chars)*/
substr(segment_name, 1, 32), /*segment name */
file_id, /*file id for extent header */
block_id, /*block id for extent header */
CEIL(blocks*4/1024) MBytes /*length of the extent, in Mega Bytes*/
from dba_extents
where tablespace_name like '%TEMP%'
order by 1, 4, 5
/ 
no rows selected
To Check Percentage Usage of Temp Tablespace
select (s.tot_used_blocks/f.total_blocks)*100 as "percent used"
from (select sum(used_blocks) tot_used_blocks
from v$sort_segment where tablespace_name='TEMP') s,
(select sum(blocks) total_blocks
from dba_temp_files where tablespace_name='TEMP') f;
percent used
------------
  .073242188

To find Sort Segment Usage by Users
select username,sum(extents) "Extents",sum(blocks) "Block"
from v$sort_usage
group by username;
USERNAME        Extents      Block
------------ ---------- ----------
MT_GG_USER            2        256
TOTALPLANT            2        256
RAIL_EVENT_M          2        256
ANAGER
MESTSV1               4        512
SYS                   2        256


To find Sort Segment Usage by a particular User
SELECT s.username,s.sid,s.serial#,u.tablespace, u.contents, u.extents, u.blocks
FROM v$session s, v$sort_usage u
WHERE s.saddr=u.session_addr
order by u.blocks desc;

To find Total Free space in Temp Tablespace

select 'FreeSpace ' || (free_blocks*8)/1024/1024 ||' GB' from v$sort_segment where tablespace_name='TEMP';

select tablespace_name , (free_blocks*8)/1024/1024 FreeSpaceInGB,
(used_blocks*8)/1024/1024 UsedSpaceInGB,
(total_blocks*8)/1024/1024 TotalSpaceInGB
from v$sort_segment where tablespace_name like '%TEMP%'

Get 10 sessions with largest temp usage
cursor bigtemp_sids is
select * from (
select s.sid,
s.status,
s.sql_hash_value sesshash,
u.SQLHASH sorthash,
s.username,
u.tablespace,
sum(u.blocks*p.value/1024/1024) mbused ,
sum(u.extents) noexts,
nvl(s.module,s.program) proginfo,
floor(last_call_et/3600)||':'||
floor(mod(last_call_et,3600)/60)||':'||
mod(mod(last_call_et,3600),60) lastcallet
from v$sort_usage u,
v$session s,
v$parameter p
where u.session_addr = s.saddr
and p.name = 'db_block_size'
group by s.sid,s.status,s.sql_hash_value,u.sqlhash,s.username,u.tablespace,
nvl(s.module,s.program),
floor(last_call_et/3600)||':'||
floor(mod(last_call_et,3600)/60)||':'||
mod(mod(last_call_et,3600),60)
order by 7 desc,3)
where rownum < 11;

SQL : tablesize
COLUMN TABLE_NAME FORMAT A32
COLUMN OBJECT_NAME FORMAT A32
COLUMN OWNER FORMAT A10

SELECT
owner,
table_name,
TRUNC(sum(bytes)/1024/1024) Meg,
ROUND( ratio_to_report( sum(bytes) ) over () * 100) Percent
FROM
(SELECT segment_name table_name, owner, bytes
FROM dba_segments
WHERE segment_type = 'TABLE'
UNION ALL
SELECT i.table_name, i.owner, s.bytes
FROM dba_indexes i, dba_segments s
WHERE s.segment_name = i.index_name
AND s.owner = i.owner
AND s.segment_type = 'INDEX'
UNION ALL
SELECT l.table_name, l.owner, s.bytes
FROM dba_lobs l, dba_segments s
WHERE s.segment_name = l.segment_name
AND s.owner = l.owner
AND s.segment_type = 'LOBSEGMENT'
UNION ALL
SELECT l.table_name, l.owner, s.bytes
FROM dba_lobs l, dba_segments s
WHERE s.segment_name = l.index_name
AND s.owner = l.owner
AND s.segment_type = 'LOBINDEX')
WHERE owner in UPPER('&owner')
GROUP BY table_name, owner
HAVING SUM(bytes)/1024/1024 > 10 /* Ignore really small tables */
ORDER BY SUM(bytes) desc
;

===========
UNDO USAGE
==========
RAC UNDO 

-- Show undo information.
--
 
SET PAUSE ON
SET PAUSE 'Press Return to Continue'
SET PAGESIZE 60
SET LINESIZE 300
 
COLUMN username FORMAT A20
COLUMN sid FORMAT 9999
COLUMN serial# FORMAT 99999
 
SELECT s.inst_id,
       s.username,
       s.sid,
       s.serial#,
       t.used_ublk,
       t.used_urec,
       rs.segment_name,
       r.rssize,
       r.status
FROM   gv$transaction t,
       gv$session s,
       gv$rollstat r,
       dba_rollback_segs rs
WHERE  s.saddr = t.ses_addr
AND    s.inst_id = t.inst_id
AND    t.xidusn = r.usn
AND    t.inst_id = r.inst_id
AND    rs.segment_id = t.xidusn
ORDER BY t.used_ublk DESC
/


select vt.used_ublk from v$transaction vt, v$session vs where vs.taddr=vt.addr and vs.sid=&&sid;

column username format a6

SELECT a.name,b.status , d.username , d.sid , d.serial#
FROM   v$rollname a,v$rollstat b, v$transaction c , v$session d
WHERE  a.usn = b.usn
AND    a.usn = c.xidusn
AND    c.ses_addr = d.saddr
AND    a.name IN ( 
		  SELECT segment_name
		  FROM dba_segments 
		  WHERE tablespace_name = 'UNDOTBS3'
		 );


PL/SQL to display information about potential issues and recommendations for fixing
the problem:
SET SERVEROUT ON SIZE 1000000
DECLARE
pro VARCHAR2(200);
rec VARCHAR2(200);
rtn VARCHAR2(200);
ret NUMBER;
utb NUMBER;
retval NUMBER;
BEGIN
DBMS_OUTPUT.PUT_LINE(DBMS_UNDO_ADV.UNDO_ADVISOR(1));
DBMS_OUTPUT.PUT_LINE('Required Undo Size (megabytes): ' || DBMS_UNDO_ADV.REQUIRED_UNDO_SIZE
(900));
retval := DBMS_UNDO_ADV.UNDO_HEALTH(pro, rec, rtn, ret, utb);
DBMS_OUTPUT.PUT_LINE('Problem: ' || pro);
DBMS_OUTPUT.PUT_LINE('Advice: ' || rec);
DBMS_OUTPUT.PUT_LINE('Rational: ' || rtn);
DBMS_OUTPUT.PUT_LINE('Retention: ' || TO_CHAR(ret));
DBMS_OUTPUT.PUT_LINE('UTBSize: ' || TO_CHAR(utb));
END;
/
If no issues are found, a 0 will be returned for the retention size.

whouseundo.sql
SELECT r.name rbs,
NVL(s.username, 'None') oracle_user,
s.osuser client_user,
p.username unix_user,
TO_CHAR(s.sid)||','||TO_CHAR(s.serial#) as sid_serial, p.spid unix_pid, t.used_ublk * TO_NUMBER(x.value)/1024 as undo_kb FROM v$process p, v$rollname r, v$session s, v$transaction t, v$parameter x WHERE s.taddr = t.addr AND s.paddr = p.addr(+) AND r.usn = t.xidusn(+) AND x.name = 'db_block_size' 
ORDER
BY r.name
; 

or: 
select s.sid, s.serial#, s.osuser, s.logon_time, s.status
,s.machine, t.used_ublk
,t.used_ublk*16384/1024/1024 undo_usage_mb
,q.sql_text
from v$session s
,v$transaction t
,v$sql q
where t.addr = s.taddr
and s.sql_id = q.sql_id;

SQL> 
SELECT DISTINCT tablespace_name,STATUS, SUM(BYTES), COUNT(*)
FROM DBA_UNDO_EXTENTS GROUP BY tablespace_name,STATUS;

TABLESPACE_NAME                STATUS    SUM(BYTES)   COUNT(*)
------------------------------ --------- ---------- ----------
UNDOTBS1                       UNEXPIRED   65536000         78
UNDOTBS1                       EXPIRED     23330816         41


Actual Undo Size 
===================================
SELECT SUM(a.bytes)/1024/1024 "UNDO_SIZE"
  FROM v$datafile a,
       v$tablespace b,
       dba_tablespaces c
 WHERE c.contents = 'UNDO'
   AND c.status = 'ONLINE'
   AND b.name = c.tablespace_name
   AND a.ts# = b.ts#; 

 UNDO_SIZE
----------
  209715200 

Undo Blocks per Second 
===========================================
SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
      "UNDO_BLOCK_PER_SEC"
  FROM v$undostat; 

UNDO_BLOCK_PER_SEC
------------------
        3.12166667 

DB Block Size 
====================================================
SELECT TO_NUMBER(value) "DB_BLOCK_SIZE [KByte]"
 FROM v$parameter
WHERE name = 'db_block_size'; 

DB_BLOCK_SIZE [Byte]
--------------------
                4096 

Optimal Undo Retention 
==========================
209'715'200 / (3.12166667 * 4'096) = 16'401 [Sec] 

Using Inline Views, you can do all in one query! 

SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       ROUND((d.undo_size / (to_number(f.value) *
       g.undo_block_per_sec))) "OPTIMAL UNDO RETENTION [Sec]"
  FROM (
       SELECT SUM(a.bytes) undo_size
          FROM v$datafile a,
               v$tablespace b,
               dba_tablespaces c
         WHERE c.contents = 'UNDO'
           AND c.status = 'ONLINE'
           AND b.name = c.tablespace_name
           AND a.ts# = b.ts#
       ) d,
       v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
              undo_block_per_sec
         FROM v$undostat
       ) g
WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size'
/ 

ACTUAL UNDO SIZE [MByte]
------------------------
200

UNDO RETENTION [Sec]
--------------------
10800

OPTIMAL UNDO RETENTION [Sec]
----------------------------
16401 


Again, all in one query: 

SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       (TO_NUMBER(e.value) * TO_NUMBER(f.value) *
       g.undo_block_per_sec) / (1024*1024) 
      "NEEDED UNDO SIZE [MByte]"
  FROM (
       SELECT SUM(a.bytes) undo_size
         FROM v$datafile a,
              v$tablespace b,
              dba_tablespaces c
        WHERE c.contents = 'UNDO'
          AND c.status = 'ONLINE'
          AND b.name = c.tablespace_name
          AND a.ts# = b.ts#
       ) d,
      v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
         undo_block_per_sec
         FROM v$undostat
       ) g
 WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size'
/

ACTUAL UNDO SIZE [MByte]
------------------------
UNDO RETENTION [Sec]
--------------------------------------------------------------------------------
NEEDED UNDO SIZE [MByte]
------------------------
                    8192
21600
              13525.5938



The previous query may return a "NEEDED UNDO SIZE" that is less than the "ACTUAL UNDO SIZE". If this is the case, you may be wasting space. You can choose to resize your UNDO tablespace to a lesser value or increase your UNDO_RETENTION parameter to use the additional space. 

undo size used by each session that is currently active

select s.sid, 
       s.username,
       sum(ss.value) / 1024 / 1024 as undo_size_mb
from  v$sesstat ss
  join v$session s on s.sid = ss.sid
  join v$statname stat on stat.statistic# = ss.statistic#
where stat.name = 'undo change vector size'
and s.type <> 'BACKGROUND'
and s.username IS NOT NULL
group by s.sid, s.username;
SELECT s.sid, s.serial#, s.username, s.osuser, p.spid,
s.machine, p.terminal, s.program
FROM v$session s, v$process p
WHERE s.paddr = p.addr
and s.sid=&SID ;
